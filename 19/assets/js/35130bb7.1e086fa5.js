"use strict";(self.webpackChunkhardware_software_interface=self.webpackChunkhardware_software_interface||[]).push([[5888],{5680:(e,r,i)=>{i.d(r,{xA:()=>p,yg:()=>u});var n=i(6540);function t(e,r,i){return r in e?Object.defineProperty(e,r,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[r]=i,e}function a(e,r){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),i.push.apply(i,n)}return i}function o(e){for(var r=1;r<arguments.length;r++){var i=null!=arguments[r]?arguments[r]:{};r%2?a(Object(i),!0).forEach((function(r){t(e,r,i[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(i,r))}))}return e}function s(e,r){if(null==e)return{};var i,n,t=function(e,r){if(null==e)return{};var i,n,t={},a=Object.keys(e);for(n=0;n<a.length;n++)i=a[n],r.indexOf(i)>=0||(t[i]=e[i]);return t}(e,r);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)i=a[n],r.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(t[i]=e[i])}return t}var l=n.createContext({}),d=function(e){var r=n.useContext(l),i=r;return e&&(i="function"==typeof e?e(r):o(o({},r),e)),i},p=function(e){var r=d(e.components);return n.createElement(l.Provider,{value:r},e.children)},g="mdxType",m={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},y=n.forwardRef((function(e,r){var i=e.components,t=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),g=d(i),y=t,u=g["".concat(l,".").concat(y)]||g[y]||m[y]||a;return i?n.createElement(u,o(o({ref:r},p),{},{components:i})):n.createElement(u,o({ref:r},p))}));function u(e,r){var i=arguments,t=r&&r.mdxType;if("string"==typeof e||t){var a=i.length,o=new Array(a);o[0]=y;var s={};for(var l in r)hasOwnProperty.call(r,l)&&(s[l]=r[l]);s.originalType=e,s[g]="string"==typeof e?e:t,o[1]=s;for(var d=2;d<a;d++)o[d]=i[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,i)}y.displayName="MDXCreateElement"},5558:(e,r,i)=>{i.r(r),i.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var n=i(8168),t=(i(6540),i(5680));const a={},o="Division of Two Numbers",s={unversionedId:"Lab 6 - Registers and Memory Addressing/Registers/Drills/Tasks/Divide/README",id:"Lab 6 - Registers and Memory Addressing/Registers/Drills/Tasks/Divide/README",title:"Division of Two Numbers",description:"In the support/divide.asm program, the quotient and remainder of two numbers represented as bytes are calculated.",source:"@site/docs/Lab 6 - Registers and Memory Addressing/Registers/Drills/Tasks/Divide/README.md",sourceDirName:"Lab 6 - Registers and Memory Addressing/Registers/Drills/Tasks/Divide",slug:"/Lab 6 - Registers and Memory Addressing/Registers/Drills/Tasks/Divide/",permalink:"/hardware-software-interface/19/Lab 6 - Registers and Memory Addressing/Registers/Drills/Tasks/Divide/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Tasks",permalink:"/hardware-software-interface/19/Lab 6 - Registers and Memory Addressing/Registers/Drills/Tasks/"},next:{title:"Multiplying Two Numbers",permalink:"/hardware-software-interface/19/Lab 6 - Registers and Memory Addressing/Registers/Drills/Tasks/Multiply/"}},l={},d=[],p={toc:d},g="wrapper";function m(e){let{components:r,...i}=e;return(0,t.yg)(g,(0,n.A)({},p,i,{components:r,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"division-of-two-numbers"},"Division of Two Numbers"),(0,t.yg)("p",null,"In the ",(0,t.yg)("inlineCode",{parentName:"p"},"support/divide.asm")," program, the quotient and remainder of two numbers represented as bytes are calculated.\nUpdate the area marked with ",(0,t.yg)("inlineCode",{parentName:"p"},"TODO")," to perform divisions ",(0,t.yg)("inlineCode",{parentName:"p"},"dividend2 / divisor2")," (word-type divisor) and ",(0,t.yg)("inlineCode",{parentName:"p"},"dividend3 / divisor3")," (dword-type divisor)."),(0,t.yg)("p",null,"Similar to the ",(0,t.yg)("inlineCode",{parentName:"p"},"mul")," instruction, the registers where the dividend is placed vary depending on the representation size of the divisor.\nThe divisor is passed as an argument to the ",(0,t.yg)("inlineCode",{parentName:"p"},"div")," mnemonic."),(0,t.yg)("blockquote",null,(0,t.yg)("p",{parentName:"blockquote"},(0,t.yg)("strong",{parentName:"p"},"TIP"),": If the divisor is of type ",(0,t.yg)("inlineCode",{parentName:"p"},"byte")," (8 bits), the components are arranged as follows:"),(0,t.yg)("ul",{parentName:"blockquote"},(0,t.yg)("li",{parentName:"ul"},"the dividend is placed in the ",(0,t.yg)("inlineCode",{parentName:"li"},"ax")," register"),(0,t.yg)("li",{parentName:"ul"},"the argument of the ",(0,t.yg)("inlineCode",{parentName:"li"},"div")," instruction is 8 bits and can be represented by a register or an immediate value"),(0,t.yg)("li",{parentName:"ul"},"the quotient is placed in ",(0,t.yg)("inlineCode",{parentName:"li"},"al")),(0,t.yg)("li",{parentName:"ul"},"the remainder is placed in ",(0,t.yg)("inlineCode",{parentName:"li"},"ah"))),(0,t.yg)("p",{parentName:"blockquote"},"If the divisor is of type ",(0,t.yg)("inlineCode",{parentName:"p"},"word")," (16 bits), the components are arranged as follows:"),(0,t.yg)("ul",{parentName:"blockquote"},(0,t.yg)("li",{parentName:"ul"},"the dividend is arranged in the ",(0,t.yg)("inlineCode",{parentName:"li"},"dx:ax")," pair, meaning its ",(0,t.yg)("inlineCode",{parentName:"li"},"high")," part is in the ",(0,t.yg)("inlineCode",{parentName:"li"},"dx")," register, and the ",(0,t.yg)("inlineCode",{parentName:"li"},"low")," part is in ",(0,t.yg)("inlineCode",{parentName:"li"},"ax")),(0,t.yg)("li",{parentName:"ul"},"the argument of the ",(0,t.yg)("inlineCode",{parentName:"li"},"div")," instruction is 16 bits and can be represented by a register or an immediate value"),(0,t.yg)("li",{parentName:"ul"},"the quotient is placed in ",(0,t.yg)("inlineCode",{parentName:"li"},"ax")),(0,t.yg)("li",{parentName:"ul"},"the remainder is placed in ",(0,t.yg)("inlineCode",{parentName:"li"},"dx"))),(0,t.yg)("p",{parentName:"blockquote"},"If the divisor is of type ",(0,t.yg)("inlineCode",{parentName:"p"},"dword")," (32 bits), the components are arranged as follows:"),(0,t.yg)("ul",{parentName:"blockquote"},(0,t.yg)("li",{parentName:"ul"},"the dividend is arranged in the ",(0,t.yg)("inlineCode",{parentName:"li"},"edx:eax")," pair, meaning its ",(0,t.yg)("inlineCode",{parentName:"li"},"high")," part is in the ",(0,t.yg)("inlineCode",{parentName:"li"},"edx")," register, and the ",(0,t.yg)("inlineCode",{parentName:"li"},"low")," part is in ",(0,t.yg)("inlineCode",{parentName:"li"},"eax")),(0,t.yg)("li",{parentName:"ul"},"the argument of the ",(0,t.yg)("inlineCode",{parentName:"li"},"div")," instruction is 32 bits and can be represented by a register or an immediate value"),(0,t.yg)("li",{parentName:"ul"},"the quotient is placed in ",(0,t.yg)("inlineCode",{parentName:"li"},"eax")),(0,t.yg)("li",{parentName:"ul"},"the remainder is placed in ",(0,t.yg)("inlineCode",{parentName:"li"},"edx"))),(0,t.yg)("p",{parentName:"blockquote"},(0,t.yg)("strong",{parentName:"p"},"TIP"),': If the program gives you a "SIGFPE.\nArithmetic exception," you most likely forgot to initialize the upper part of the dividend (',(0,t.yg)("inlineCode",{parentName:"p"},"ah"),", ",(0,t.yg)("inlineCode",{parentName:"p"},"dx"),", or ",(0,t.yg)("inlineCode",{parentName:"p"},"edx"),").")),(0,t.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,t.yg)("a",{parentName:"p",href:"/hardware-software-interface/19/Lab%206%20-%20Registers%20and%20Memory%20Addressing/Registers/Reading/"},"this")," reading material."))}m.isMDXComponent=!0}}]);