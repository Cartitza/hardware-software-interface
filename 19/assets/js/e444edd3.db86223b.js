"use strict";(self.webpackChunkhardware_software_interface=self.webpackChunkhardware_software_interface||[]).push([[6768],{5680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>y});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var d=r.createContext({}),l=function(e){var n=r.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=l(e.components);return r.createElement(d.Provider,{value:n},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,d=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=l(t),g=a,y=m["".concat(d,".").concat(g)]||m[g]||p[g]||o;return t?r.createElement(y,s(s({ref:n},c),{},{components:t})):r.createElement(y,s({ref:n},c))}));function y(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=g;var i={};for(var d in n)hasOwnProperty.call(n,d)&&(i[d]=n[d]);i.originalType=e,i[m]="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=t[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},8556:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var r=t(8168),a=(t(6540),t(5680));const o={},s="Memory Addressing",i={unversionedId:"Lab 6 - Registers and Memory Addressing/Memory Addressing/Reading/README",id:"Lab 6 - Registers and Memory Addressing/Memory Addressing/Reading/README",title:"Memory Addressing",description:"Modern x86 processors can address up to 2^32 bytes of memory, which means memory addresses are represented on 32 bits.",source:"@site/docs/Lab 6 - Registers and Memory Addressing/Memory Addressing/Reading/README.md",sourceDirName:"Lab 6 - Registers and Memory Addressing/Memory Addressing/Reading",slug:"/Lab 6 - Registers and Memory Addressing/Memory Addressing/Reading/",permalink:"/hardware-software-interface/19/Lab 6 - Registers and Memory Addressing/Memory Addressing/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Memory Addressing",permalink:"/hardware-software-interface/19/Lab 6 - Registers and Memory Addressing/Memory Addressing/"},next:{title:"Guides",permalink:"/hardware-software-interface/19/Lab 6 - Registers and Memory Addressing/Memory Addressing/Guides/"}},d={},l=[{value:"Size Directives",id:"size-directives",level:2},{value:"Loop Instruction",id:"loop-instruction",level:2}],c={toc:l},m="wrapper";function p(e){let{components:n,...t}=e;return(0,a.yg)(m,(0,r.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"memory-addressing"},"Memory Addressing"),(0,a.yg)("p",null,"Modern x86 processors can address up to 2^32 bytes of memory, which means memory addresses are represented on 32 bits.\nTo address memory, the processor uses addresses (implicitly, each label is translated into a corresponding memory address).\nBesides labels, there are other forms of addressing memory:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov eax, [0xcafebab3]         ; direct (displacement)\nmov eax, [esi]                ; indirect (base)\nmov eax, [ebp-8]              ; based (base + displacement)\nmov eax, [ebx*4 + 0xdeadbeef] ; indexed (index * scale + displacement)\nmov eax, [edx + ebx + 12]     ; based and indexed without scale (base + index + displacement)\nmov eax, [edx + ebx*4 + 42]   ; based and indexed with scale (base + index * scale + displacement)\n")),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},(0,a.yg)("strong",{parentName:"p"},"WARNING"),": The following addressing modes are invalid:"),(0,a.yg)("pre",{parentName:"blockquote"},(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov eax, [ebx-ecx]     ; Registers can only be added\nmov [eax+esi+edi], ebx ; The address calculation can involve at most 2 registers\n"))),(0,a.yg)("h2",{id:"size-directives"},"Size Directives"),(0,a.yg)("p",null,"Generally, the size of a value brought from memory can be inferred from the instruction code used.\nFor example, in the above addressing modes, the size of the values could be inferred from the size of the destination register, but in some cases, this is not so obvious.\nLet's consider the following instruction:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov [ebx], 2\n")),(0,a.yg)("p",null,"As seen, it intends to store the value 2 at the address contained in the ",(0,a.yg)("inlineCode",{parentName:"p"},"ebx")," register.\nThe size of the register is 4 bytes.\nThe value 2 can be represented on both 1 and 4 bytes.\nIn this case, since both interpretations are valid, the processor needs additional information on how to treat this value.\nThis can be done through size directives:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov byte [ebx], 2  ; Move the value 2 into the byte at the address contained in ebx.\nmov word [ebx], 2  ; Move the entire 2 represented in 16 bits into the 2 bytes\n                   ; starting from the address contained in ebx.\nmov dword [ebx], 2 ; Move the entire 2 represented in 32 bits into the 4 bytes\n                   ; starting from the address contained in ebx.\n")),(0,a.yg)("h2",{id:"loop-instruction"},"Loop Instruction"),(0,a.yg)("p",null,"The loop instruction is used for loops with a predetermined number of iterations, loaded into the ",(0,a.yg)("inlineCode",{parentName:"p"},"ecx")," register.\nIts syntax is as follows:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov ecx, 10 ; Initialize ecx with the number of iterations\nlabel:\n; loop content\nloop label\n")),(0,a.yg)("p",null,"At each iteration, the ",(0,a.yg)("inlineCode",{parentName:"p"},"ecx")," register is decremented, and if it's not equal to 0, the execution jumps to the specified label.\nThere are other forms of the instruction that additionally check the ZF flag:"),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Mnemonic"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"LOOPE/LOOPZ label"),(0,a.yg)("td",{parentName:"tr",align:null},"Decrement ",(0,a.yg)("inlineCode",{parentName:"td"},"ecx"),"; jump to label if ",(0,a.yg)("inlineCode",{parentName:"td"},"ecx")," != 0 and ",(0,a.yg)("inlineCode",{parentName:"td"},"ZF")," == 1")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"LOOPNE/LOOPNZ label"),(0,a.yg)("td",{parentName:"tr",align:null},"Decrement ",(0,a.yg)("inlineCode",{parentName:"td"},"ecx"),"; jump to label if ",(0,a.yg)("inlineCode",{parentName:"td"},"ecx")," != 0 and ",(0,a.yg)("inlineCode",{parentName:"td"},"ZF")," != 1")))),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},(0,a.yg)("strong",{parentName:"p"},"NOTE"),": When using jumps in an assembly language program, it's important to consider the difference between a ",(0,a.yg)("inlineCode",{parentName:"p"},"short jump")," (near jump) and a ",(0,a.yg)("inlineCode",{parentName:"p"},"long jump")," (far jump).\nType and example  | Size and significance                                     |Description\n------------------|-----------------------------------------------------------|------------\nShort Jump (loop) | 2 bytes (one byte for the opcode and one for the address) | The relative address of the instruction to which the jump is intended must not be more than 128 bytes away from the current instruction address.\nLong Jump (jmp)   | 3 bytes (one byte for the opcode and two for the address) | The relative address of the instruction to which the jump is intended must not be more than 32768 bytes away from the current instruction address.")))}p.isMDXComponent=!0}}]);