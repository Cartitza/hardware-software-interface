"use strict";(self.webpackChunkhardware_software_interface=self.webpackChunkhardware_software_interface||[]).push([[3859],{5680:(e,t,r)=>{r.d(t,{xA:()=>c,yg:()=>g});var n=r(6540);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},s=Object.keys(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),u=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",y={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=u(r),p=a,g=d["".concat(l,".").concat(p)]||d[p]||y[p]||s;return r?n.createElement(g,i(i({ref:t},c),{},{components:r})):n.createElement(g,i({ref:t},c))}));function g(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=r.length,i=new Array(s);i[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:a,i[1]=o;for(var u=2;u<s;u++)i[u]=r[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},7752:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>y,frontMatter:()=>s,metadata:()=>o,toc:()=>u});var n=r(8168),a=(r(6540),r(5680));const s={},i="Laboratory 07: Structured Data (Structures, Arrays and String Operations)",o={unversionedId:"Lab 7 - Structures, vectors and strings/Structures, vectors and strings/Reading/README",id:"Lab 7 - Structures, vectors and strings/Structures, vectors and strings/Reading/README",title:"Laboratory 07: Structured Data (Structures, Arrays and String Operations)",description:"In this laboratory, we will introduce the concept of structure in assembly language and work with specialized operations on strings.",source:"@site/docs/Lab 7 - Structures, vectors and strings/Structures, vectors and strings/Reading/README.md",sourceDirName:"Lab 7 - Structures, vectors and strings/Structures, vectors and strings/Reading",slug:"/Lab 7 - Structures, vectors and strings/Structures, vectors and strings/Reading/",permalink:"/hardware-software-interface/20/Lab 7 - Structures, vectors and strings/Structures, vectors and strings/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Structures, vectors and strings",permalink:"/hardware-software-interface/20/Lab 7 - Structures, vectors and strings/Structures, vectors and strings/"},next:{title:"Guides",permalink:"/hardware-software-interface/20/Lab 7 - Structures, vectors and strings/Structures, vectors and strings/Guides/"}},l={},u=[{value:"Structures",id:"structures",level:2},{value:"Declaring a Structure",id:"declaring-a-structure",level:3},{value:"Instantiating a Structure",id:"instantiating-a-structure",level:3},{value:"Accessing Values from a Structure",id:"accessing-values-from-a-structure",level:3},{value:"Arrays",id:"arrays",level:2},{value:"Declaring an Array",id:"declaring-an-array",level:3},{value:"Arrays of Structures",id:"arrays-of-structures",level:2},{value:"Declaring an Array of Structures",id:"declaring-an-array-of-structures",level:3},{value:"Traversing an Array of Structures",id:"traversing-an-array-of-structures",level:3}],c={toc:u},d="wrapper";function y(e){let{components:t,...r}=e;return(0,a.yg)(d,(0,n.A)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"laboratory-07-structured-data-structures-arrays-and-string-operations"},"Laboratory 07: Structured Data (Structures, Arrays and String Operations)"),(0,a.yg)("p",null,"In this laboratory, we will introduce the concept of structure in assembly language and work with specialized operations on strings."),(0,a.yg)("h2",{id:"structures"},"Structures"),(0,a.yg)("p",null,"Structures are used to group data of different types that can be used together to create a composite type."),(0,a.yg)("p",null,"Next, we will go through the steps necessary to use a structure: declaration, instantiation, and accessing the fields of a structure."),(0,a.yg)("h3",{id:"declaring-a-structure"},"Declaring a Structure"),(0,a.yg)("p",null,"In NASM, a structure is declared using the construction ",(0,a.yg)("inlineCode",{parentName:"p"},"struc <structure name>"),", followed by a list of fields and terminated with ",(0,a.yg)("inlineCode",{parentName:"p"},"endstruc"),"."),(0,a.yg)("p",null,"Each field of the structure is defined by the following: a label (used to access members), the type specifier, and the number of elements."),(0,a.yg)("p",null,"Example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"struc mystruct\n    a:    resw 1    ; a will refer to a single word-sized element\n    b:    resd 1    ; b will refer to a single double-word-sized element\n    c:    resb 1    ; c will refer to a single byte-sized element\n    d:    resd 1    ; d will refer to a single double-word-sized element\n    e:    resb 6    ; e will refer to 6 byte-sized elements\nendstruc\n")),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},(0,a.yg)("strong",{parentName:"p"},"NOTE"),": Here pseudo-instructions from the NASM ",(0,a.yg)("inlineCode",{parentName:"p"},"res")," family are used to define the data type and the number of elements for each of the structure fields.\nFor more details about the ",(0,a.yg)("inlineCode",{parentName:"p"},"res")," syntax, please follow this link: ",(0,a.yg)("a",{parentName:"p",href:"https://www.nasm.us/doc/nasmdoc3.html#section-3.2.2"},"NASM Documentation"))),(0,a.yg)("p",null,"Each label defining a field represents the offset of the field within the structure.\nFor example, ",(0,a.yg)("inlineCode",{parentName:"p"},"b")," will have the value 2, because there are 2 bytes from the beginning of the structure to the ",(0,a.yg)("inlineCode",{parentName:"p"},"b")," field (the first 2 bytes are occupied by the ",(0,a.yg)("inlineCode",{parentName:"p"},"a")," word)."),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},(0,a.yg)("strong",{parentName:"p"},"WARNING"),": If you want to use the same field name in two different structures, you must prefix the label name with a dot (",(0,a.yg)("inlineCode",{parentName:"p"},"."),") like this:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"struc mystruct1\n    .a:    resw 1\n    .b:    resd 1\nendstruc\n\nstruc mystruct2\n    .a:    resd 16\n    .b:    resw 1\nendstruc\n")),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"Use the construction ",(0,a.yg)("inlineCode",{parentName:"p"},"mystruct2.b")," to find the offset value of 'b' within the structure ",(0,a.yg)("inlineCode",{parentName:"p"},"mystruct2"),".")),(0,a.yg)("h3",{id:"instantiating-a-structure"},"Instantiating a Structure"),(0,a.yg)("p",null,"One way to have a structure in memory is to declare it statically in the ",(0,a.yg)("inlineCode",{parentName:"p"},".data")," section.\nThe syntax uses NASM macros ",(0,a.yg)("inlineCode",{parentName:"p"},"istruc")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"iend")," along with the ",(0,a.yg)("inlineCode",{parentName:"p"},"at")," keyword."),(0,a.yg)("p",null,"In the following example, static instantiation of the structure declared above is presented, where ",(0,a.yg)("inlineCode",{parentName:"p"},"struct_var")," is the memory address where the data begins."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"struct_var:\n    istruc mystruct\n        at a, dw        -1\n        at b, dd        0x12345678\n        at c, db        ' '\n        at d, dd        23\n        at e, db        'Gary', 0\n    iend\n")),(0,a.yg)("p",null,"If you define the structure fields using a dot (",(0,a.yg)("inlineCode",{parentName:"p"},"."),"), the instantiation of the structure is done as follows:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"struct_var:\n    istruc mystruct\n        at mystruct.a, dw        -1\n        at mystruct.b, dd        0x12345678\n        at mystruct.c, db        ' '\n        at mystruct.d, dd        23\n        at mystruct.e, db        'Gary', 0\n    iend\n")),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},(0,a.yg)("strong",{parentName:"p"},"WARNING"),": To avoid initializing members incorrectly, you must ensure that for each field, the data type in instantiation matches the type in declaration.")),(0,a.yg)("h3",{id:"accessing-values-from-a-structure"},"Accessing Values from a Structure"),(0,a.yg)("p",null,"To access and/or modify a specific member of the instantiated structure, we need to know its address.\nThis address can be obtained by calculating the sum of the starting address of the structure and the offset within the structure of the desired member."),(0,a.yg)("p",null,"The following code sequence demonstrates setting a value in the ",(0,a.yg)("inlineCode",{parentName:"p"},"b")," field of the structure and subsequently displaying the value of this field."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov eax, 12345\nmov dword [struct + b], eax ; the address of field b is the base address of the statically instantiated structure + the offset of the field (given by the label 'b')\n\nmov ebx, dword [struct + b] ; putting the value from field b into the ebx register for display\nPRINTF32 `%d\\n\\x0`, ebx\n")),(0,a.yg)("h2",{id:"arrays"},"Arrays"),(0,a.yg)("p",null,"We can consider an array as a sequence of elements of the same type, placed contiguously in memory.\nYou might have noticed something similar in previous labs when declaring static character strings in the ",(0,a.yg)("inlineCode",{parentName:"p"},".data")," section."),(0,a.yg)("h3",{id:"declaring-an-array"},"Declaring an Array"),(0,a.yg)("p",null,"In general, declared static data can be initialized or uninitialized.\nDifferentiation is made both by providing an initial value for initialized data and by the NASM syntax used."),(0,a.yg)("p",null,"For example, to declare an array of 100 words initialized with the value 42, we will use the construction:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"section .data\n    myVect:    times 100    dw 42\n")),(0,a.yg)("p",null,'On the other hand, if we want to declare an uninitialized array of 20 double-word elements, we use instructions from the "res" family as follows:'),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"section .bss\n    myVect:    resd 20\n")),(0,a.yg)("h2",{id:"arrays-of-structures"},"Arrays of Structures"),(0,a.yg)("p",null,"Often, we'll need arrays that contain elements larger than a double word.\nTo achieve this, we'll combine the two concepts presented earlier and use arrays of structures.\nOf course, string operation instructions will not work, so we'll have to resort to the classic method of accessing elements: explicit memory addressing."),(0,a.yg)("p",null,"For the example in this section, we create a structure representing a point in a 2D space."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"struc point\n    .x:    resd 1\n    .y:    resd 1\nendstruc\n")),(0,a.yg)("h3",{id:"declaring-an-array-of-structures"},"Declaring an Array of Structures"),(0,a.yg)("p",null,"Since NASM doesn't support any mechanism to explicitly declare an array of structures, we'll need to effectively declare a data section to accommodate our array."),(0,a.yg)("p",null,"Suppose we want a zero-initialized array of 100 elements of the structure type ",(0,a.yg)("inlineCode",{parentName:"p"},"point")," (which is 8 bytes in size), we need to allocate 100 * 8 (= 800) bytes."),(0,a.yg)("p",null,"We obtain:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"section .data\n    pointArray:    times 800    db 0\n")),(0,a.yg)("p",null,"In addition, NASM provides an alternative to manually calculating the size of a structure by automatically generating the macro ",(0,a.yg)("inlineCode",{parentName:"p"},"<structure name>_size"),".\nThus, the previous example can become:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"section .data\n    pointArray:    times point_size * 100    db 0\n")),(0,a.yg)("p",null,"If we want to declare an uninitialized array of structures, we can use:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"section .bss\n    pointArray:    resb point_size * 100\n")),(0,a.yg)("h3",{id:"traversing-an-array-of-structures"},"Traversing an Array of Structures"),(0,a.yg)("p",null,'As mentioned before, to access a field of an element in an array, we need to use normal addressing (particularly "based-indexed with scale" addressing).\nThe formula to find the address of the element is ',(0,a.yg)("inlineCode",{parentName:"p"},"base_of_array + i * size_of_struct"),"."),(0,a.yg)("p",null,"Assuming we have the start address of the array in the ",(0,a.yg)("inlineCode",{parentName:"p"},"ebx")," register and the index of the element we want to access in the ",(0,a.yg)("inlineCode",{parentName:"p"},"eax")," register, the following example demonstrates printing the value of the y field of this element."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov ebx, pointArray                             ; Move the start address of the array into ebx\nmov eax, 13                                     ; Assume we want the 13th element\nmov edx, [ebx + point_size * eax + point.y]     ; Calculate the address of the desired field between []\n                                                ; and then transfer the value from that address\n                                                ; into the edx register\n\nPRINTF32 `%u\\n\\x0`, edx\n")),(0,a.yg)("p",null,"We traverse the array, having the current index in the eax register at each iteration.\nWe can print the values from both fields of each element in the array with the following program:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"struc   point\n    .x: resd 1\n    .y: resd 1\nendstruc\n\nsection .data\n    pointArray: times point_size * 100 db 0\n\nsection .text\n    global CMAIN\n\nCMAIN:\n    push ebp\n    mov ebp, esp\n\n    xor edx, edx\n    xor eax, eax\n\nlabel:\n    mov edx, [pointArray + point_size * eax + point.x] ; acces\u0103m membrul x\n    PRINTF32 `%u\\n\\x0`, edx\n\n    mov edx, [pointArray + point_size * eax + point.y] ; acces\u0103m membrul y\n    PRINTF32 `%u\\n\\x0`, edx\n\n    inc eax ; incrementarea indicelui de iterare\n    cmp eax, 100\n    jl label\n\n    leave\n    ret\n")))}y.isMDXComponent=!0}}]);