"use strict";(self.webpackChunkhardware_software_interface=self.webpackChunkhardware_software_interface||[]).push([[3249],{5680:(e,t,a)=>{a.d(t,{xA:()=>c,yg:()=>m});var n=a(6540);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},g="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),g=p(a),h=r,m=g["".concat(o,".").concat(h)]||g[h]||u[h]||i;return a?n.createElement(m,s(s({ref:t},c),{},{components:a})):n.createElement(m,s({ref:t},c))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=h;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[g]="string"==typeof e?e:r,s[1]=l;for(var p=2;p<i;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},7098:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var n=a(8168),r=(a(6540),a(5680));const i={},s="Functions",l={unversionedId:"Lab 9 - Functions/Functions/Reading/README",id:"Lab 9 - Functions/Functions/Reading/README",title:"Functions",description:"In this lab, we'll discuss how function calls are performed. We'll see how we can use the call and ret instructions to make function calls and how we use the stack to pass function parameters.",source:"@site/docs/Lab 9 - Functions/Functions/Reading/README.md",sourceDirName:"Lab 9 - Functions/Functions/Reading",slug:"/Lab 9 - Functions/Functions/Reading/",permalink:"/hardware-software-interface/21/Lab 9 - Functions/Functions/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Functions",permalink:"/hardware-software-interface/21/Lab 9 - Functions/Functions/"},next:{title:"Guides",permalink:"/hardware-software-interface/21/Lab 9 - Functions/Functions/Guides/"}},o={},p=[{value:"Passing Parameters",id:"passing-parameters",level:2},{value:"Function Call",id:"function-call",level:2},{value:"Stack Operation",id:"stack-operation",level:3},{value:"Caller and Callee",id:"caller-and-callee",level:2},{value:"Remarks:",id:"remarks",level:3}],c={toc:p},g="wrapper";function u(e){let{components:t,...i}=e;return(0,r.yg)(g,(0,n.A)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"functions"},"Functions"),(0,r.yg)("p",null,"In this lab, we'll discuss how function calls are performed. We'll see how we can use the ",(0,r.yg)("inlineCode",{parentName:"p"},"call")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"ret")," instructions to make function calls and how we use the stack to pass function parameters."),(0,r.yg)("p",null,'The lab follows a "learn by doing" format, with practical parts alternating between tutorial sections, which guide you step by step, and exercises to be solved.'),(0,r.yg)("h2",{id:"passing-parameters"},"Passing Parameters"),(0,r.yg)("p",null,"When it comes to calling a function with parameters, there are two major options for placing them:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Register Passing")," - this method intuitively involves passing parameters through registers."),(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Advantages")),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"It is very easy to use when the number of parameters is small."),(0,r.yg)("li",{parentName:"ul"},"It is very fast since parameters are immediately accessible from registers.")),(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Disadvantages")),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Because there is a limited number of registers, the number of parameters for a function becomes limited."),(0,r.yg)("li",{parentName:"ul"},"It's very likely that some registers are used inside the called function, and it becomes necessary to temporarily save registers on the stack before the function call. Thus, the second advantage listed disappears because accessing the stack involves working with memory, meaning increased latency."))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Stack Passing")," - this method involves pushing all parameters onto the stack."),(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Advantages")),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"A large number of parameters can be passed.")),(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Disadvantages")),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"It's slow because it involves memory access."),(0,r.yg)("li",{parentName:"ul"},"More complicated in terms of parameter access.")))),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"NOTE:")," For ",(0,r.yg)("strong",{parentName:"p"},"32-bit")," architectures, the stack passing method is used, while for ",(0,r.yg)("strong",{parentName:"p"},"64-bit")," architectures, the register passing method is used. We will use the convention for 32-bit architecture.")),(0,r.yg)("h2",{id:"function-call"},"Function Call"),(0,r.yg)("p",null,"When we call a function, the steps are as follows:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"We put the arguments on the stack, pushing them in the reverse order in which they are sent as function arguments."),(0,r.yg)("li",{parentName:"ul"},"We call ",(0,r.yg)("inlineCode",{parentName:"li"},"call"),"."),(0,r.yg)("li",{parentName:"ul"},"We restore the stack at the end of the call.")),(0,r.yg)("h3",{id:"stack-operation"},"Stack Operation"),(0,r.yg)("p",null,"As we know, stack operations fall into two types:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"push val")," where the value ",(0,r.yg)("inlineCode",{parentName:"li"},"val")," is placed on the stack"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"pop reg/mem")," where what is on the top of the stack is placed into a register or memory area")),(0,r.yg)("p",null,"When we ",(0,r.yg)("inlineCode",{parentName:"p"},"push"),", we say that the stack ",(0,r.yg)("strong",{parentName:"p"},"grows")," (elements are added). For reasons that will be better explained later, the stack pointer (indicated by the ",(0,r.yg)("inlineCode",{parentName:"p"},"esp")," register in 32-bit mode) decreases in value when the stack grows (on ",(0,r.yg)("inlineCode",{parentName:"p"},"push"),"). However, this contradiction in naming comes from the fact that the stack is typically represented vertically, with smaller values at the top and larger values at the bottom."),(0,r.yg)("p",null,"Similarly, when we ",(0,r.yg)("inlineCode",{parentName:"p"},"pop"),", we say that the stack ",(0,r.yg)("strong",{parentName:"p"},"shrinks")," (elements are removed). Now the stack pointer (indicated by the ",(0,r.yg)("inlineCode",{parentName:"p"},"esp")," register in 32-bit mode) increases in value."),(0,r.yg)("p",null,"A summary of this is explained very well ",(0,r.yg)("a",{parentName:"p",href:"https://en.wikibooks.org/wiki/X86_Disassembly/The_Stack"},"here"),"."),(0,r.yg)("p",null,"For example, if we have the function ",(0,r.yg)("inlineCode",{parentName:"p"},"foo")," with the following signature (in C language):"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-C"},"int foo(int a, int b, int c);\n")),(0,r.yg)("p",null,"The call to this function will look like this:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov ecx, [c]     ; take the value of parameter c from a memory location\nmov ebx, [b]\nmov eax, [a]\n\npush ecx         ; put parameters in reverse order, starting with c\npush ebx         ; then b\npush eax         ; then a\ncall foo         ; call the function\nadd esp, 12      ; restore the stack\n")),(0,r.yg)("h2",{id:"caller-and-callee"},"Caller and Callee"),(0,r.yg)("p",null,"When we call a function, we say that the calling function (the context that calls) is the ",(0,r.yg)("strong",{parentName:"p"},"caller"),", while the called function is the ",(0,r.yg)("strong",{parentName:"p"},"callee"),". In the previous paragraph, we discussed how things look at the caller level (how we build the stack)."),(0,r.yg)("p",null,"Now let's see what happens at the callee level. Until the ",(0,r.yg)("inlineCode",{parentName:"p"},"call")," instruction, the stack contains the function's parameters. The ",(0,r.yg)("inlineCode",{parentName:"p"},"call")," can be roughly equated to the following sequence:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Assembly"},"push eip\njmp function_name\n")),(0,r.yg)("p",null,"That is, even the ",(0,r.yg)("inlineCode",{parentName:"p"},"call")," uses the stack and saves the address of the next instruction, the one after the ",(0,r.yg)("inlineCode",{parentName:"p"},"call"),", also known as the ",(0,r.yg)("strong",{parentName:"p"},"return address"),". This is necessary for the callee to know where to return to in the caller."),(0,r.yg)("p",null,"In the callee, at its beginning (called preamble), the frame pointer is saved (in the i386 architecture, this is the ",(0,r.yg)("inlineCode",{parentName:"p"},"ebp")," register), with the frame pointer then referring to the current function stack frame. This is crucial for accessing parameters and local variables via an offset from the frame pointer."),(0,r.yg)("p",null,"Although not mandatory, saving the frame pointer helps in debugging and is used in most cases. For these reasons, any function call will generally have a preamble:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Assembly"},"push ebp\nmov ebp, esp\n")),(0,r.yg)("p",null,"These modifications take place in the callee. Therefore, it is the responsibility of the callee to restore the stack to its old value. Hence, it is customary to have an epilogue that restores the stack to its initial state; this epilogue is:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Assembly"},"leave\n")),(0,r.yg)("p",null,"After this instruction, the stack is as it was at the beginning of the function (immediately after the call)."),(0,r.yg)("p",null,"To conclude the function, it is necessary for the execution to return and continue from the instruction following the ",(0,r.yg)("inlineCode",{parentName:"p"},"call")," that started the function. This involves influencing the ",(0,r.yg)("inlineCode",{parentName:"p"},"eip")," register and putting back the value that was saved on the stack initially by the ",(0,r.yg)("inlineCode",{parentName:"p"},"call")," instruction. This is achieved using the instruction:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Assembly"},"ret\n")),(0,r.yg)("p",null,"which is roughly equivalent to the instruction:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Assembly"},"pop eip\n")),(0,r.yg)("p",null,"For example, the definition and body of the function foo, which calculates the sum of 3 numbers, would look like this:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Assembly"},"\nfoo:\n    push ebp\n    mov ebp, esp\n\n    mov eax, [ebp + 8]\n    mov ebx, [ebp + 12]\n    mov ecx, [ebp + 16]\n\n    add eax, ebx\n    add eax, ecx\n\n    leave\n    ret\n")),(0,r.yg)("h3",{id:"remarks"},"Remarks:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"A function is defined by a label.")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"After the function's preamble, the stack looks as follows:"),(0,r.yg)("p",{parentName:"li"},(0,r.yg)("img",{alt:"stack.svg",src:a(725).A}))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Note that during the execution of the function, what does not change is the position of the frame pointer. This is the reason for its name: it points to the current function's frame. Therefore, it is common to access a function's parameters through the frame pointer. Assuming a 32-bit system and processor word-sized parameters (32 bits, 4 bytes), we will have:"),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"the first argument is found at address ",(0,r.yg)("inlineCode",{parentName:"li"},"ebp+8")),(0,r.yg)("li",{parentName:"ul"},"the second argument is found at address ",(0,r.yg)("inlineCode",{parentName:"li"},"ebp+12")),(0,r.yg)("li",{parentName:"ul"},"the third argument is found at address ",(0,r.yg)("inlineCode",{parentName:"li"},"ebp+16")),(0,r.yg)("li",{parentName:"ul"},"etc.")),(0,r.yg)("p",{parentName:"li"},"This is why, to get the parameters of the foo function in the eax, ebx, ecx registers, we use the constructions:"))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Assembly"},"   mov eax, dword [ebp+8]   ; first argument in eax\n   mov ebx, dword [ebp+12]  ; second argument in ebx\n   mov ecx, dword [ebp+16]  ; third argument in ecx\n")),(0,r.yg)("ol",{start:4},(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"The return value of a function is placed in registers (generally in eax)."),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"If the return value is ",(0,r.yg)("strong",{parentName:"p"},"8 bits"),", the function's result is placed in ",(0,r.yg)("inlineCode",{parentName:"p"},"al"),".")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"If the return value is ",(0,r.yg)("strong",{parentName:"p"},"16 bits"),", the function's result is placed in ",(0,r.yg)("inlineCode",{parentName:"p"},"ax"),".")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"If the return value is ",(0,r.yg)("strong",{parentName:"p"},"32 bits"),", the function's result is placed in ",(0,r.yg)("inlineCode",{parentName:"p"},"eax"),".")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"If the return value is ",(0,r.yg)("strong",{parentName:"p"},"64 bits"),", the result is placed in the ",(0,r.yg)("inlineCode",{parentName:"p"},"edx")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"eax")," registers. The most significant 32 bits are placed in ",(0,r.yg)("inlineCode",{parentName:"p"},"edx"),", and the rest in the ",(0,r.yg)("inlineCode",{parentName:"p"},"eax")," register."),(0,r.yg)("p",{parentName:"li"},(0,r.yg)("em",{parentName:"p"},"Additionally, in some cases, a memory address can be returned to the stack/heap (eg. malloc), or other memory areas, which refer to the desired object after the function call."))))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"A function uses the same hardware registers; therefore, when exiting the function, the values of the registers are no longer the same. To avoid this situation, some/all registers can be saved on the stack."))),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"NOTE:"),"  Since assembly languages offer more opportunities, there is a need for calling conventions in x86. The difference between them may consist of the parameter order, how the parameters are passed to the function, which registers need to be preserved by the callee or whether the caller or callee handles stack preparation. More details can be found ",(0,r.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/X86_calling_conventions"},"here")," or ",(0,r.yg)("a",{parentName:"p",href:"https://levelup.gitconnected.com/x86-calling-conventions-a34812afe097"},"here")," if Wikipedia is too mainstream for you.\nFor us, the registers ",(0,r.yg)("inlineCode",{parentName:"p"},"eax"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"ecx"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"edx")," are considered ",(0,r.yg)("strong",{parentName:"p"},"clobbered")," (or volatile), and the calee can do whatever it wants to them. On the other hand, the calee has to ensure that ",(0,r.yg)("inlineCode",{parentName:"p"},"ebx")," exits the function with the same value it has entered with.")))}u.isMDXComponent=!0},725:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/stack-7e53a701b7907c4331d4dfc24028236a.svg"}}]);