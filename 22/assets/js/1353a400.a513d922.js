"use strict";(self.webpackChunkhardware_software_interface=self.webpackChunkhardware_software_interface||[]).push([[7268],{5680:(e,t,a)=>{a.d(t,{xA:()=>c,yg:()=>m});var n=a(6540);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(a),d=o,m=u["".concat(l,".").concat(d)]||u[d]||h[d]||r;return a?n.createElement(m,s(s({ref:t},c),{},{components:a})):n.createElement(m,s({ref:t},c))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,s=new Array(r);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:o,s[1]=i;for(var p=2;p<r;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},6468:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>p});var n=a(8168),o=(a(6540),a(5680));const r={},s="Introduction to the Stack",i={unversionedId:"Lab 8 - The Stack/Introduction/Reading/README",id:"Lab 8 - The Stack/Introduction/Reading/README",title:"Introduction to the Stack",description:"In this lab, we will learn about how the stack is represented in assembly language, its utility, and how to it could be useful to us.",source:"@site/docs/Lab 8 - The Stack/Introduction/Reading/README.md",sourceDirName:"Lab 8 - The Stack/Introduction/Reading",slug:"/Lab 8 - The Stack/Introduction/Reading/",permalink:"/hardware-software-interface/22/Lab 8 - The Stack/Introduction/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Introduction",permalink:"/hardware-software-interface/22/Lab 8 - The Stack/Introduction/"},next:{title:"Guides",permalink:"/hardware-software-interface/22/Lab 8 - The Stack/Introduction/Guides/"}},l={},p=[{value:"Stack data structure - reminder",id:"stack-data-structure---reminder",level:2},{value:"So, why is it useful?",id:"so-why-is-it-useful",level:2},{value:"Stack Operations",id:"stack-operations",level:2},{value:"Stack in the context of a process&#39;s address space",id:"stack-in-the-context-of-a-processs-address-space",level:2},{value:"Tricks and tips",id:"tricks-and-tips",level:2}],c={toc:p},u="wrapper";function h(e){let{components:t,...r}=e;return(0,o.yg)(u,(0,n.A)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"introduction-to-the-stack"},"Introduction to the Stack"),(0,o.yg)("p",null,"In this lab, we will learn about how the stack is represented in assembly language, its utility, and how to it could be useful to us."),(0,o.yg)("h2",{id:"stack-data-structure---reminder"},"Stack data structure - reminder"),(0,o.yg)("blockquote",null,(0,o.yg)("p",{parentName:"blockquote"},(0,o.yg)("strong",{parentName:"p"},"NOTE:")," This is a quick reminder on how the abstract data structure works.\nIf you feel like you already understand this, you can skip this part.")),(0,o.yg)("p",null,"In the world of algorithms and data structure, a \"stack\" is a data structure used to hold data, mirroring a real-life stack of objects (for example, a stack of books, or a stack of boxes).\nThis data structure's usefulness comes from optimizing the ease and speed at which elements can be added or removed from the top of the stack.\nIt forces us to think about how our data is organized relative to the stack's base and top.\nThe usual operations with the stack are:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"push")," - add an element to the top of the stack"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"pop")," - get the element from the top of the stack ",(0,o.yg)("strong",{parentName:"li"},"and remove it")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"peek")," or ",(0,o.yg)("inlineCode",{parentName:"li"},"top")," - get the element from the top of the stack ",(0,o.yg)("strong",{parentName:"li"},"without removing it"))),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"An image showing a stack data structure at different stages. The empty stack gains the element labeled &quot;1&quot; after the instruction &quot;push 1&quot; is applied to it. After the instruction &quot;push 2&quot;, the stack has two items, element 1 being below element 2. Finally, the &quot;pop&quot; instruction makes the stack lose element 2",src:a(4865).A})),(0,o.yg)("p",null,'As the above image suggests, the order in which items are inserted and removed from a stack is represented by the phrase "first in, last out".'),(0,o.yg)("h2",{id:"so-why-is-it-useful"},"So, why is it useful?"),(0,o.yg)("p",null,"In the previous chapters we learned how to work with the basics of assembly.\nA pretty big limitation we have imposed on ourselves by using such a low-level language is the small number of values we can work with at a time.\nFor anything but small programs, having just the 6 registers (",(0,o.yg)("inlineCode",{parentName:"p"},"eax"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"ebx"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"ecx"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"edx"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"esi"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"edi"),") is usually not enough, and creating global variables for temporary values is not memory efficient and, at some point, we'll struggle to even name them something reasonable!"),(0,o.yg)("p",null,"You might have also felt the absence of functions. The stack will help us out as it provides a nice place to store:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"the arguments,"),(0,o.yg)("li",{parentName:"ul"},"the values of registers before entering a function so they can be restored on exit,"),(0,o.yg)("li",{parentName:"ul"},"and some metadata useful for when we want to exit out of a function.")),(0,o.yg)("p",null,"More on this in the next lab."),(0,o.yg)("p",null,"As you might have guessed, the solution to this is to use a stack on which we can put arbitrary values onto.\nWe don't need implement it ourselves - it comes built-in \ud83d\ude04!\nWhenever a program stars, the kernel makes sure a zone of memory is allocated for the sole purpose of writing arbitrary data onto.\nMoreover, CPUs also have some specialized instructions that work directly with this memory in a way similar to how a normal stack works."),(0,o.yg)("blockquote",null,(0,o.yg)("p",{parentName:"blockquote"},(0,o.yg)("strong",{parentName:"p"},"Note"),": The size of the stack memory area is often ",(0,o.yg)("a",{parentName:"p",href:"https://stackoverflow.com/questions/54821412/how-to-increase-stack-size-when-compiling-a-c-program-using-mingw-compiler"},"set at compile-time"),".\nWhen going over the maximum allocated space, you can receive a Segmentation Fault, and the phenomenon is called a ",(0,o.yg)("inlineCode",{parentName:"p"},"Stack Overflow"),".\nYou will have probably received this error when you declare a local array with a very high capacity, or when calling a recursive function which never returns.")),(0,o.yg)("h2",{id:"stack-operations"},"Stack Operations"),(0,o.yg)("p",null,"The stack can be modified in two ways:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"By using special instructions designed for stack operations, the most common of which are ",(0,o.yg)("inlineCode",{parentName:"li"},"push")," and ",(0,o.yg)("inlineCode",{parentName:"li"},"pop"),":")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-assembly"},'%include "io.asm"\n\nsection .text\nglobal CMAIN\nCMAIN:\n\n    mov eax, 7\n    mov ebx, 8\n    add eax, ebx\n    push eax                 ; push the value of the eax register onto the stack\n    mov eax, 10              ; we can now use the eax register, as its value is saved on the stack\n    PRINTF32 `%d \\n\\x0`, eax  ; 10\n\n    pop eax                  ; retrieve the value of the eax register from the stack\n    PRINTF32 `%d \\n\\x0`, eax  ; 15\n')),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"By directly accessing the memory with the help of a special register in which the top of the stack is held - ",(0,o.yg)("inlineCode",{parentName:"li"},"esp"),' also known as the "stack pointer register".')),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-assembly"},'%include "io.asm"\n\nsection .text\nglobal CMAIN\nCMAIN:\n    mov eax, 7\n    mov ebx, 8\n    add eax, ebx\n    sub esp, 4           ; reserve 4 bytes on the stack\n    mov [esp], eax       ; move the contents of the eax register to the new address pointed to by esp\n    mov eax, 10\n    PRINTF32 `%d \\n\\x0`, eax\n\n    mov eax, [esp]       ; retrieve the value from the stack\n    add esp, 4           ; restore the value of the esp register\n    PRINTF32 `%d \\n\\x0`, eax\n')),(0,o.yg)("blockquote",null,(0,o.yg)("p",{parentName:"blockquote"},(0,o.yg)("strong",{parentName:"p"},"IMPORTANT:")," Comment out the instructions ",(0,o.yg)("inlineCode",{parentName:"p"},"sub esp, 4")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"add esp, 4"),".\nWhat happens?\nWhy?"),(0,o.yg)("p",{parentName:"blockquote"},(0,o.yg)("strong",{parentName:"p"},"NOTE:")," The stack is used to remember the return address when a function is called.\n",(0,o.yg)("strong",{parentName:"p"},"Note that the stack grows from higher addresses to lower addresses."),"\nThis is why memory allocation on the stack is done using the ",(0,o.yg)("inlineCode",{parentName:"p"},"sub")," instruction, and deallocation is done using the ",(0,o.yg)("inlineCode",{parentName:"p"},"add")," instruction.")),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"stack_image",src:a(5640).A})),(0,o.yg)("p",null,"Some processors do not have support for stack operations: for example, MIPS processors do not have ",(0,o.yg)("inlineCode",{parentName:"p"},"push")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"pop")," instructions and do not have a special register for the stack pointer.\nThus, if we want to implement stack operations on a MIPS processor, we would do it exactly as in the example above, but we can choose any register to keep track of the stack pointer."),(0,o.yg)("p",null,"Therefore, the ",(0,o.yg)("inlineCode",{parentName:"p"},"push eax")," instruction on an x86 processor is equivalent to:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-assembly"},"sub esp, 4\nmov [esp], eax\n")),(0,o.yg)("p",null,"And the ",(0,o.yg)("inlineCode",{parentName:"p"},"pop eax")," is equivalent to:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-assembly"},"mov eax, [esp]\nadd esp, 4\n")),(0,o.yg)("blockquote",null,(0,o.yg)("p",{parentName:"blockquote"},(0,o.yg)("strong",{parentName:"p"},"IMPORTANT:")," We need to be careful with the amount of data allocated on the stack because the size of the stack is limited.\nOverfilling the stack will lead to the well-known error of ",(0,o.yg)("strong",{parentName:"p"},"stack overflow")," (more in the security lab)."),(0,o.yg)("p",{parentName:"blockquote"},(0,o.yg)("strong",{parentName:"p"},"NOTE:")," The default stack size on Linux for a 64-bit architecture is 8MiB.")),(0,o.yg)("h2",{id:"stack-in-the-context-of-a-processs-address-space"},"Stack in the context of a process's address space"),(0,o.yg)("p",null,"A process's address space, or more precisely, a process's virtual address space, represents the virtual memory area usable by a process.\nEach process has its own address space.\nEven in situations where two processes share a memory region, the virtual space is distinct, but it maps to the same physical memory region."),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"stack_image",src:a(1681).A,width:"253",height:"382"})),(0,o.yg)("p",null,"In the figure above, a typical process's address space is presented."),(0,o.yg)("p",null,"The four important zones in a process's address space are the data zone, the code zone, the stack, and the heap.\nAs can be observed from the figure, the stack and the heap are the zones that can grow.\nIn fact, these two zones are dynamic and only make sense in the context of a process.\nOn the other hand, the information in the data and code zones is described in the executable."),(0,o.yg)("h2",{id:"tricks-and-tips"},"Tricks and tips"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"The golden rule of stack usage is: the number of ",(0,o.yg)("inlineCode",{parentName:"p"},"push"),"-es should equal the number of ",(0,o.yg)("inlineCode",{parentName:"p"},"pop"),"-s in a function.\nGiven that the stack is used for function calls, it is very important that when a function finishes its execution, the stack pointer should be updated so that it points to the same memory location (of the stack) as it did at the time of entering the function.")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"In situations where we perform N ",(0,o.yg)("inlineCode",{parentName:"p"},"push"),"-es and reach the end of the function without doing a ",(0,o.yg)("inlineCode",{parentName:"p"},"pop")," for any of the values, we can restore the stack pointer using the ",(0,o.yg)("inlineCode",{parentName:"p"},"add")," instruction."))),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-assembly"},"section .text\nglobal CMAIN\nCMAIN:\n    mov eax, 5\n    mov ebx, 6\n    mov ecx, 7\n\n    push eax\n    push ebx\n    push ecx\n\n    add esp, 12     ; equivalent to using 3 consecutive pop-s\n    ret\n")),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"An alternative method is to save the current stack pointer value in a separate register, such as ",(0,o.yg)("inlineCode",{parentName:"li"},"ebp"),", before performing any ",(0,o.yg)("inlineCode",{parentName:"li"},"push")," operations.\nThis allows us to easily restore the stack pointer value at the end of the function, without having to keep track of the number of ",(0,o.yg)("inlineCode",{parentName:"li"},"push")," operations performed.")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-assembly"},"section .text\nglobal CMAIN\nCMAIN:\n\n    mov ebp, esp       ; save current stack pointer value in ebp\n\n    mov eax, 5\n    mov ebx, 6\n    mov ecx, 7\n\n    push eax\n    push ebx\n    push ecx\n\n    mov esp, ebp       ; restore stack pointer value\n    ret\n")),(0,o.yg)("blockquote",null,(0,o.yg)("p",{parentName:"blockquote"},(0,o.yg)("strong",{parentName:"p"},"IMPORTANT:")," What is the primary use of the ",(0,o.yg)("inlineCode",{parentName:"p"},"ebp")," register?")),(0,o.yg)("p",null,"As we can observe, the ",(0,o.yg)("inlineCode",{parentName:"p"},"ebp")," register defines the stack frame for each function.\nSimilarly to how we can address local variables using the ",(0,o.yg)("inlineCode",{parentName:"p"},"esp")," register, we can do the same with ",(0,o.yg)("inlineCode",{parentName:"p"},"ebp"),".\nAdditionally, we will see that function parameters are addressed using ",(0,o.yg)("inlineCode",{parentName:"p"},"ebp"),"."))}h.isMDXComponent=!0},1681:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/process_address_space-1b6a850e54c7237af3ca9a6b1ae6fe31.jpg"},5640:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/the-stack-growth-5b1bf5b116f559c5646cc74dd64cd802.svg"},4865:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/the-stack-bb76234db11c39d83991c27fc25aa0bd.svg"}}]);