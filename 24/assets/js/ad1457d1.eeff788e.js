"use strict";(self.webpackChunkhardware_software_interface=self.webpackChunkhardware_software_interface||[]).push([[7498],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>g});var r=n(6540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=c(n),d=a,g=u["".concat(l,".").concat(d)]||u[d]||m[d]||s;return n?r.createElement(g,i(i({ref:t},p),{},{components:n})):r.createElement(g,i({ref:t},p))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[u]="string"==typeof e?e:a,i[1]=o;for(var c=2;c<s;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9727:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var r=n(8168),a=(n(6540),n(5680));const s={},i="C - Assembly Interaction",o={unversionedId:"Lab 10 - C - Assembly Interaction/Stack Handling/Reading/README",id:"Lab 10 - C - Assembly Interaction/Stack Handling/Reading/README",title:"C - Assembly Interaction",description:"Setting the Stack",source:"@site/docs/Lab 10 - C - Assembly Interaction/Stack Handling/Reading/README.md",sourceDirName:"Lab 10 - C - Assembly Interaction/Stack Handling/Reading",slug:"/Lab 10 - C - Assembly Interaction/Stack Handling/Reading/",permalink:"/hardware-software-interface/24/Lab 10 - C - Assembly Interaction/Stack Handling/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Stack Handling",permalink:"/hardware-software-interface/24/Lab 10 - C - Assembly Interaction/Stack Handling/"},next:{title:"Drills",permalink:"/hardware-software-interface/24/Lab 10 - C - Assembly Interaction/Stack Handling/Drills/"}},l={},c=[{value:"Setting the Stack",id:"setting-the-stack",level:2},{value:"Passing Parameters from C to the Assembly Procedure",id:"passing-parameters-from-c-to-the-assembly-procedure",level:2},{value:"Tasks",id:"tasks",level:2}],p={toc:c},u="wrapper";function m(e){let{components:t,...n}=e;return(0,a.yg)(u,(0,r.A)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"c---assembly-interaction"},"C - Assembly Interaction"),(0,a.yg)("h2",{id:"setting-the-stack"},"Setting the Stack"),(0,a.yg)("p",null,"When entering a procedure, it is necessary to set a stack frame to which to send parameters.\nOf course, if the procedure does not receive parameters, this step is not necessary. So to set the stack, the following code must be included:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"push ebp\nmov ebp, esp\n")),(0,a.yg)("p",null,"The EBP gives us the ability to use it as an index within the stack and should not be altered during the procedure."),(0,a.yg)("h2",{id:"passing-parameters-from-c-to-the-assembly-procedure"},"Passing Parameters from C to the Assembly Procedure"),(0,a.yg)("p",null,"C programs send parameters to assembly procedures using the stack.\nConsider the following C program sequence:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-C"},"#include <stdio.h>\n\nextern int sum(int a, int b);  // declare the assembly procedure as external\n\nint main() {\n    int a = 5, b = 7;\n    int res = sum(a, b);  // call the assembly procedure\n\n    return 0;\n}\n")),(0,a.yg)("p",null,"When C executes the call to ",(0,a.yg)("inlineCode",{parentName:"p"},"sum()"),", it first pushes arguments on the stack in reverse order, then actually calls the procedure.\nThus, upon entering the procedure body, the stack will be intact."),(0,a.yg)("p",null,"Since the variables ",(0,a.yg)("inlineCode",{parentName:"p"},"a")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"b")," are declared as ",(0,a.yg)("inlineCode",{parentName:"p"},"int")," values, they will each use one word on the stack. This method of passing parameters is called value passing.\nThe code of the Sum procedure might look like this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"section .text\n    global sum   ; declare the procedure label as global\n\nsum:\n    push ebp\n    mov ebp, esp\n\n    mov eax, [ebp+8]     ; retrieve the first argument\n    mov ecx, [ebp+12]    ; retrieve the second argument\n    add eax, ecx         ; calculate the sum\n\n    pop ebp\n    ret\n")),(0,a.yg)("p",null,"It is interesting to note a number of things. First, the assembly code defaults the return value of the procedure to the ",(0,a.yg)("inlineCode",{parentName:"p"},"eax")," register.\nSecond, the ",(0,a.yg)("inlineCode",{parentName:"p"},"ret")," command is sufficient to exit the procedure, due to the fact that the C compiler takes care of the rest of the stuff, such as removing parameters from the stack."),(0,a.yg)("h2",{id:"tasks"},"Tasks"),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"max-assembly-calls"),": drills/tasks/max-assembly-calls/support\n",(0,a.yg)("inlineCode",{parentName:"p"},"max-c-calls"),": drills/tasks/max-c-calls/support\n",(0,a.yg)("inlineCode",{parentName:"p"},"max-c-calls-x64"),": drills/tasks/max-c-calls-x64/support\n",(0,a.yg)("inlineCode",{parentName:"p"},"stack-frame"),": drills/tasks/stack-frame/support"))}m.isMDXComponent=!0}}]);