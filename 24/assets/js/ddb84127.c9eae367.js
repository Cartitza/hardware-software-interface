"use strict";(self.webpackChunkhardware_software_interface=self.webpackChunkhardware_software_interface||[]).push([[6913],{5680:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>g});var r=n(6540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,g=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return n?r.createElement(g,s(s({ref:t},u),{},{components:n})):r.createElement(g,s({ref:t},u))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8551:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=n(8168),a=(n(6540),n(5680));const o={},s="C - Assembly Interaction",i={unversionedId:"Lab 10 - C - Assembly Interaction/Memory layout/Reading/README",id:"Lab 10 - C - Assembly Interaction/Memory layout/Reading/README",title:"C - Assembly Interaction",description:"Considering that assembly language poses challenges both in reading and in developing code, the general trend is to migrate towards high-level languages (which are much easier to read and provide a more user-friendly API).",source:"@site/docs/Lab 10 - C - Assembly Interaction/Memory layout/Reading/README.md",sourceDirName:"Lab 10 - C - Assembly Interaction/Memory layout/Reading",slug:"/Lab 10 - C - Assembly Interaction/Memory layout/Reading/",permalink:"/hardware-software-interface/24/Lab 10 - C - Assembly Interaction/Memory layout/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Memory layout",permalink:"/hardware-software-interface/24/Lab 10 - C - Assembly Interaction/Memory layout/"},next:{title:"Guides",permalink:"/hardware-software-interface/24/Lab 10 - C - Assembly Interaction/Memory layout/Guides/"}},l={},c=[{value:"Using assembly procedures in C functions",id:"using-assembly-procedures-in-c-functions",level:2},{value:"Declaration of the procedure",id:"declaration-of-the-procedure",level:3},{value:"Setting the stack",id:"setting-the-stack",level:3},{value:"Passing parameters from C to the assembly procedure",id:"passing-parameters-from-c-to-the-assembly-procedure",level:3},{value:"Calling C functions from assembly procedures",id:"calling-c-functions-from-assembly-procedures",level:2}],u={toc:c},d="wrapper";function p(e){let{components:t,...n}=e;return(0,a.yg)(d,(0,r.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"c---assembly-interaction"},"C - Assembly Interaction"),(0,a.yg)("p",null,"Considering that assembly language poses challenges both in reading and in developing code, the general trend is to migrate towards high-level languages (which are much easier to read and provide a more user-friendly API).\nHowever, there are still situations where, for optimization reasons, small assembly routines are used and integrated into the high-level language module."),(0,a.yg)("p",null,"In this laboratory, we will explore how assembly modules can be integrated into C programs and vice versa."),(0,a.yg)("h2",{id:"using-assembly-procedures-in-c-functions"},"Using assembly procedures in C functions"),(0,a.yg)("p",null,"Using assembly procedures in C functions for a C program to be executed, it must be translated into the machine code of the processor; this is the task of a compiler.\nSince this compiled code is not always optimal, in some cases it is preferable to replace portions of code written in C with portions of assembly code that do the same thing, but with better performance."),(0,a.yg)("h3",{id:"declaration-of-the-procedure"},"Declaration of the procedure"),(0,a.yg)("p",null,"In order to ensure that the assembly procedure and Module C are properly combined and compatible, the following steps must be followed:\n-declare the procedure label as global, using the GLOBAL directive. In addition to this, any data that will be used by the procedure must be declared as global.\n-using the EXTERN directive to declare procedures and global data as external."),(0,a.yg)("h3",{id:"setting-the-stack"},"Setting the stack"),(0,a.yg)("p",null,"When entering a procedure, it is necessary to set a stack frame to which to send parameters.\nOf course, if the procedure does not receive parameters, this step is not necessary. So to set the stack, the following code must be included:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"push ebp\nmov ebp, esp\n")),(0,a.yg)("p",null,"The EBP gives us the ability to use it as an index within the stack and should not be altered during the procedure."),(0,a.yg)("h3",{id:"passing-parameters-from-c-to-the-assembly-procedure"},"Passing parameters from C to the assembly procedure"),(0,a.yg)("p",null,"C programs send parameters to assembly procedures using the stack.\nConsider the following C program sequence:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-C"},"#include <stdio.h>\n\nextern int sum(int a, int b);  // declare the assembly procedure as external\n\nint main() {\n    int a = 5, b = 7;\n    int res = sum(a, b);  // call the assembly procedure\n\n    return 0;\n}\n")),(0,a.yg)("p",null,"When C executes the call to ",(0,a.yg)("inlineCode",{parentName:"p"},"sum"),", it first pushes arguments on the stack in reverse order, then actually calls the procedure.\nThus, upon entering the procedure body, the stack will be intact."),(0,a.yg)("p",null,"Since the variables ",(0,a.yg)("inlineCode",{parentName:"p"},"a")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"b")," are declared as ",(0,a.yg)("inlineCode",{parentName:"p"},"int")," values, they will each use one word on the stack. This method of passing parameters is called value passing.\nThe code of the Sum procedure might look like this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},"section .text\n    global sum   ; declare the procedure label as global\n\nsum:\n    push ebp\n    mov ebp, esp\n\n    mov eax, [ebp+8]     ; retrieve the first argument\n    mov ecx, [ebp+12]    ; retrieve the second argument\n    add eax, ecx         ; calculate the sum\n\n    pop ebp\n    ret\n")),(0,a.yg)("p",null,"It is interesting to note a number of things. First, the assembly code defaults the return value of the procedure to the ",(0,a.yg)("inlineCode",{parentName:"p"},"eax")," register.\nSecond, the ",(0,a.yg)("inlineCode",{parentName:"p"},"ret")," command is sufficient to exit the procedure, due to the fact that the C compiler takes care of the rest of the stuff, such as removing parameters from the stack."),(0,a.yg)("h2",{id:"calling-c-functions-from-assembly-procedures"},"Calling C functions from assembly procedures"),(0,a.yg)("p",null,"In most cases, calling routines or functions from the standard C library in an assembly language program is a much more complex operation than vice versa.\nTake the example of calling the ",(0,a.yg)("inlineCode",{parentName:"p"},"printf")," function from an assembly language program:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Assembly"},'global main\n\nexternal printf\n\nsection .data\n\ntext db "291 is the best!", 10, 0\nstrformat db "%s", 0\n\nsection .code\n\nmain\n        push dword text\n        push dword strformat\n        call printf\n        add esp, 8\n        ret\n')),(0,a.yg)("p",null,"Note that the procedure is declared as global and is called ",(0,a.yg)("inlineCode",{parentName:"p"},"main")," - the starting point of any C program. Since in C the parameters are stacked in reverse order, the string offset is set first, followed by the format string offset. The C function can be called afterwards, but the stack must be restored when the function exits."),(0,a.yg)("p",null,"When linking assembly code the standard C library (or the library containing the functions you use) must be included."))}p.isMDXComponent=!0}}]);