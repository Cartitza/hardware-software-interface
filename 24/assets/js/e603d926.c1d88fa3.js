"use strict";(self.webpackChunkhardware_software_interface=self.webpackChunkhardware_software_interface||[]).push([[4424],{5680:(e,t,r)=>{r.d(t,{xA:()=>p,yg:()=>d});var n=r(6540);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(r),m=a,d=u["".concat(c,".").concat(m)]||u[m]||f[m]||o;return r?n.createElement(d,i(i({ref:t},p),{},{components:r})):n.createElement(d,i({ref:t},p))}));function d(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},3577:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>f,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var n=r(8168),a=(r(6540),r(5680));const o={},i="Corrupt stack frame debugging",s={unversionedId:"Lab 10 - C - Assembly Interaction/Stack/Drills/Tasks/Stack Frame/README",id:"Lab 10 - C - Assembly Interaction/Stack/Drills/Tasks/Stack Frame/README",title:"Corrupt stack frame debugging",description:"In current subdirectory of the lab's task archive you can find a C program that implements the display of the string Hello world! by a call to the print_hello() function defined in the assembly for the first part of the message, followed by two calls to the printf() function directly from the C code.",source:"@site/docs/Lab 10 - C - Assembly Interaction/Stack/Drills/Tasks/Stack Frame/README.md",sourceDirName:"Lab 10 - C - Assembly Interaction/Stack/Drills/Tasks/Stack Frame",slug:"/Lab 10 - C - Assembly Interaction/Stack/Drills/Tasks/Stack Frame/",permalink:"/hardware-software-interface/24/Lab 10 - C - Assembly Interaction/Stack/Drills/Tasks/Stack Frame/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Maximum computation in assembly with 64-bit C call",permalink:"/hardware-software-interface/24/Lab 10 - C - Assembly Interaction/Stack/Drills/Tasks/Max C Calls x64/"}},c={},l=[],p={toc:l},u="wrapper";function f(e){let{components:t,...r}=e;return(0,a.yg)(u,(0,n.A)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"corrupt-stack-frame-debugging"},"Corrupt stack frame debugging"),(0,a.yg)("p",null,"In current subdirectory of the lab's task archive you can find a C program that implements the display of the string ",(0,a.yg)("inlineCode",{parentName:"p"},"Hello world!")," by a call to the ",(0,a.yg)("inlineCode",{parentName:"p"},"print_hello()")," function defined in the assembly for the first part of the message, followed by two calls to the ",(0,a.yg)("inlineCode",{parentName:"p"},"printf()")," function directly from the C code."),(0,a.yg)("p",null,"Compile and run the program.\nWhat do you notice?\nThe printed message is not as expected because the assembly code is missing an instruction."),(0,a.yg)("p",null,"Use GDB to inspect the address at the top of the stack before executing the ",(0,a.yg)("inlineCode",{parentName:"p"},"ret")," statement in the ",(0,a.yg)("inlineCode",{parentName:"p"},"print_hello()")," function.\nWhat does it point to? Track the values of the EBP and ESP registers during the execution of this function.\nWhat should be at the top of the stack after execution of the ",(0,a.yg)("inlineCode",{parentName:"p"},"leave")," statement?"),(0,a.yg)("p",null,"Find the missing instruction and rerun the executable."),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},(0,a.yg)("strong",{parentName:"p"},"TIP:"),"\nIn order to restore the stack to its state at the start of the current function, the ",(0,a.yg)("inlineCode",{parentName:"p"},"leave")," statement relies on the function's pointer frame having been set.")))}f.isMDXComponent=!0}}]);